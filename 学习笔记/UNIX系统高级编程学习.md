# UNIX系统高级编程学习

## 第0章 
* gdb小工具
    * 查看结构体定义 ptype va_list
    * 查看内存值： x/s 0x7ffeefbffa7e
    * 查看字符串的值 p *str@3 (如果只是p *str，只会取得首地址的char值)
    * centos下，查看宏内容 `gcc -g3 -gdwarf-2 d_fun.c` `macro expand MAX(a, b)`

## 第一章 UNIX基础知识
* apue.h找不到解决办法 `http://www.01happy.com/unix-advanced-programming-apue/`
* 路径： 以斜线开头的路径名为`绝对路径名`（absolute pathname），否则称为`相对路径名`（relative pathname）
* 工作目录： 每个进程都有一个`工作目录`（working directory），有时称为`当前工作目录`（current working directory）。所有相对路径都是从工作目录开始解释。进程可以用chdir函数来更改其工作目录。(p6)
* 文件描述符（file descriptor）：通常是一个小的非负整数，内核用它标识一个特定进程正在访问的文件。当内核打开一个已有文件或创建一个新文件时，它返回一个文件描述符。在读、写文件时，就可使用它。
* 不用缓冲的I/O：函数open、read、write、lseek以及close提供了不用缓冲的I/O。这些函数都使用文件描述符。
    * [浅谈无缓存I/O操作和标准I/O文件操作区别 （转载）](https://blog.csdn.net/cowbane/article/details/6630298)
    * [云笔记链接](https://note.youdao.com/share/?id=c9d45b3f69752afa82e6f10ba207f985&type=note#/)
* 程序（program）：存放在磁盘上、处于某个目录中的一个可执行文件。
* 进程（process）：程序的执行实例被称为进程（process）；UNIX系统确保每个进程都有一个唯一的数字标识符，称为`进程ID（process ID）`。进程ID总是一个非负整数。（p10）
* fork：调用fork创建一个新进程。新进程是调用进程的复制品，我们称调用进程为父进程，新创建的进程为子进程。fork向父进程返回新子进程的进程ID（非负），对子进程则返回0.因为fork创建一新进程，所以说它被调用一次（由父进程），但返回两次（分别在父进程及子进程中）。
* execlp： 从PATH环境变量中查找文件并执行
* 线程和线程ID：通常，一个进程只有一个`控制线程（thread）`，同一时刻只执行一组机器指令。对于某些问题，如果不同部分各使用一个控制线程，那么整个问题解决起来就容易得多。另外，多个控制线程也能充分利用多处理器系统的并行性。
    * 在一个进程内的所有线程共享同一地址空间、文件描述符、栈以及进程相关的属性。因为它们能访问同一存储区，所以各线程在访问共享数据时需要采取同步措施以避免不一致性。
    * 与进程相同，线程也用ID标识。但是，线程ID只在它所属进程内起作用。一个进程中的线程ID在另一个进程中并无意义。当在一个进程中对多个线程进行操作时，我们用线程ID引用相应的线程。
    * 控制线程的函数与控制进程的函数类似，但另有一套。在进程模型建立很久之后，线程模型才被引入到UNIX系统中，这两个模型之间存在复杂的相互作用。S12中见 （p13）
* 信号（signal）： 通知进程已发生某种情况的一种技术。进程处理信号有三种选择：
    * 忽略该信号。
    * 按系统默认方式处理。如：对于除以0的情况，系统默认方式是终止该进程。
    * 提供一个函数，信号发生时则调用该函数，这被称为捕捉该信号。使用这种方式，我们只要提供自编的函数就将能知道什么时候产生了信号，并按所希望的方式处理它。
* kill函数：在一个进程中调用此函数就可向另一个进程发送一个信号。当然这样做也有限制：`当向一个进程发送信号时，我们必须时该进程所有者或者是超级用户。`
* 时间值
* void指针
    1. 在C语言中在任何时候都可以用void类型的指针来代替其他类型的指针，void指针可以指向任何数据类型的变量
    2. 如果要通过void指针去获取它所指向的变量值时候，需要先将void指针强制类型转换成和变量名类型想匹配的数据类型指针后再进行操作；

    ```
    指针的强类类型转化：
    void  *p;
    int *pa = (int *)p;
    然后才能对原来的void指针指向的空间进行操作
    任何类型的指针都可以赋值给void指针，无需进行强制类型转换；
    float f = 1.22f;
    float *p1 = &f;
    p = p1;//将float指针赋值被p

    ```
    3. 函数指针
* 反编译c代码
    * gcc -g -o test.c
    * objdump -S test.o

## 第二章 UNIX标准化及实现
* 内存对齐
* 在用#define 定义时 , 斜杠("\")是用来续行的，"#"用来把参数转换成字符串，是给参数加上双引号。"##"则用来连接前后两个参数，把它们变成一个字符串,"#@"是给参数加上单引号