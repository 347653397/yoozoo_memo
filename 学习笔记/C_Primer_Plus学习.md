

# C_Primer_Plus学习

## 第三章 数据和C
### 位、字节、字
> 1. 最小的存储单元是**位**（bit）
> 2. **字节**（byte）是常用的计算机存储单位，1 byte = 8 bit
> 3. **字**（word）是设计计算机时给定的自然存储单位。有8位、16位、32位，以及目前的64位。计算机的字长越大，其数据转移越快，允许的内存访问也更多。

### 浮点数

> 浮点数和整数的存储方案不同。

### 机器字长

> 1. 计算机进行一次整数运算所能处理的二进制数据的位数（整数运算即定点整数运算），字长的值是不固定的。
>
> 2. 字长并非一个十分严格的概念。在一个 CPU 指令集中，每条指令都可以处理长度不同的操作数。这时就把大多数指令能处理的最长长度但是又不花费额外周期的操作数长度称为字长。比如说，大多数指令都能处理 8 位， 16 位， 32 位数据，但是处理32位数据要花费更多的时钟周期，而处理 32 位数据要花费更多的时钟周期，而处理 8 位和 16 位的时间一样，那么就称字长是 16 位。
>
> 3. 计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。
>
> 4. 如果你的机器是 32 位的，int 的长度为 32 位，如果你的机器是 64 位的，那么 int 的标准长度就是 64 位。
>
>    > 比如 16 位机上，`sizeof(int) = 2`，而 32 位机上 `sizeof(int) = 4`。但是在 32 位机器和 64 位机器中 int 类型都是占用 4 个字节，因为一般编译器可以根据自身硬件来选择合适的大小。当前主流的编译器中一般是 32 位机器和 64 位机器中的 int 都是 4 个字节（例如 GCC）。

### 寄存器

> 1. Register，是中央处理器内的其中组成部门。寄存器是有限存储容量的高速存储部件，它们可用来暂存`指令`、`数据`、`地址`。在中央处理器的控制部件中，包含的寄存器有`指令寄存器`（IR）和`程序计数器`。在中央处理器的算术及逻辑部件中，包含的寄存器有`累加器`。参考：[计算机组成原理-指令系统](http://staff.ustc.edu.cn/~llxx/cod/courseware/2_ISA.pdf)
>
> 2. CPU 位数 = CPU 中寄存器的位数 = CPU 能够一次并行处理的数据宽度（位数） = 数据总线宽度
>
>    > 现在的计算机处理器一般都是 64 位，这是硬件的事。

### 指令的执行

> 1. 处理器执行的程序是由一组保存在存储器中的指令组成的。
> 2. 一个单一的指令需要处理称为一个指令周期。
> 3. 程序计数器（Program Counter，PC）保存下一次要取的指令地址。

### 内存位宽

> 在一个时钟周期内所能传送数据的位数，位数越大则瞬间所能传输的数据量越大，是内存的重要参数之一。

### 数据总线

> 1. 是 CPU 与内存或其他器件之间的数据传送的通道。
> 2. 数据总线的宽度决定了 CPU 和外界的数据传送速度。
> 3. 每条传输线一次只能传输 1 位二进制数据。e.g. 8 根数据线一次可传送一个 8 位二进制数据（即一个字节）
> 4. 数据总线是数据线数量之和。

### 地址总线

> 1. CPU 是通过地址总线来指定存储单元的。
> 2. 地址总线决定了 CPU 所能访问的最大内存空间的大小。e.g. 10 根地址线能访问的最大的内存位 1024 位二进制数据（1B）
> 3. 地址总线是地址线数量之和。

### 控制总线

> 1. CPU 通过控制总线对外部器件进行控制。
> 2. 控制总线的宽度决定了 CPU 对外部器件的控制能力。
> 3. 控制总线是控制线数量之和。

### 内存对齐

> 1. 在现代计算机体系中，每次读写内存中数据，都是按字。
> 2. 内存地址对齐是计算机语言自动进行的，也即是编译器所做的工作。
> 3. 基本数据对齐
>    1. x86，32 位系统下，基于Microsoft、Borland、GNU 的编译器，有如下数据对齐规则
>       1. 一个 char（占用 1-Byte）变量以 1-Byte 对齐
>       2. 一个 short（占用 2-Byte）变量以 2-Byte 对齐
>       3. 一个 int（占用 4-Byte）变量以 4-Byte 对齐。
>       4. 一个 long、float（占用4-Byte）变量以 4-Bypte 对齐。
>       5. 一个 double（占用 8-Byte）变量以 8-Byte 对齐。
>       6. 一个 long double（占用 12-Byte）变量以 4-Byte 对齐。
>       7. 任何 pointer（占用 4-Byte）变量以 4-Byte 对齐。
>    2. 而在 64 位系统下，与上面规则对比有如下不同：
>       1. 一个 long、double（占用 8-Byte） 变量以 8-Byte 对齐。
>       2. 一个 long double（占用 16-Byte）变量以 16-Byte 对齐。
>       3. 任何 pointer（占用 8-Byte）变量以 8-Byte 对齐。
> 4. 结构体数据对齐
>    1. 在结构体中的第一个成员的首地址等于整个结构体的变量的首地址，而后的成员的地址随着它声明的顺序和实际占用的字节数递增。为了总的结构体大小对齐，会在结构体中插入一些没有实际意义的字符来填充（padding）结构体。
>    2. 三大规则
>       1. 结构体中的第一个成员的首地址 = 结构体变量的首地址。
>       2. 结构体中的`每一个成员的首地址` 相对于结构体的首地址的`偏移量（offset）`是该成员 **min_num** 的整数倍。**min_num=min(#pragma pack()指定的数，这个数据成员的自身长度) **
>       3. 结构体的总大小是`对齐模数`（`#pragma pack(n)`所制定的n与结构体中`最大数据类型的成员大小`的最小值）的`整数倍` 即：**min(对齐模数，结构体中最大数据类型的成员大小)**

### 指令流水

>  是指为提高处理器执行指令的效率，把一条指令的操作分成多个细小的步骤，每个步骤由专门的电路完成。

### 三元式

> 是把表达式及语句表示成一组三元式，每个三元式由运算符 op，运算对象 arg1，运算对象2 arg2 组成，形如(op,arg1,arg2)。

### typedef

> * 使用 typedef 的第 2 个原因是：typedef 常用于给复杂的类型命名。例如，下面的声明：
>
>   > `typedef  char (* FRPTC ()) [5]; ` 
>
>   > 把 FRPTC 声明为一个函数类型，该函数返回一个指针，该指针指向内含 5 个 char 类型元素的数组。
>
> * 使用 typedef 时要记住，typedef 并没有创建任何新类型，它只是为某个已存在的类型增加了一个方便使用的标签。
>
> * 1. 为复杂的声明定义一个新的简单的别名。方法是：在原来的声明里逐步用别名替换一部分复杂声明，如此循环，把带变量名的部分留到最后替换，得到的就是原声明的最简化。[参考文章1](https://www.cnblogs.com/csyisong/archive/2009/01/09/1372363.html)
>
>   > 举例：
>   >
>   > 原声明：` void (*b[10])(void (*)());`（变量名为 `b`，先替换右边部分括号里的， `pFunParam` 为别名一： `typedef void (*pFunParam)();` 再替换左边的变量 `b`， pFunx 为别名二：`typedef void (*pFunx)(pFunParam);
>   >
>   > 原声明的最简化版：`pFunx b[10];`
>
>   > 理解：
>   >
>   > 复杂声明可用“右左法则”：从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是先右后左的顺序，如此循环，知道整个声明分析完。
>   >
>   > 例如：` int (*func)(int *p);`
>   >
>   > 首先找到变量名` func`，外面右一对圆括号，而且左右是一个 * 号，这说明 `func` 是一个指针；然后跳出这个圆括号，先看右边，又遇到圆括号，这说明 `(*func)` 是一个函数，所以 `func` 是一个指向这类函数的指针，即`函数指针`，这类函数具有 `int *` 类型的形参，返回值类型是 `int`。
>   >
>   > 例如：`int (*func[5])(int *);`
>   >
>   > `func` 右边是一个 `[]` 运算符，说明 `func` 是具有 5 个元素的数组；`func` 的左边有一个 *，说明 `func` 的元素是指针（注意这里的 * 不是修饰 `func`，而是修饰 `func[5]` 的，原因是 [] 运算符优先级比 * 高， `func` 先跟 [] 结合）。跳出这个括号，看右边，又遇到圆括号，说明 `func` 数组的元素是函数类型的指针，它指向的函数具有 int * 类型的形参，返回值类型为 int。
>
> * 2. 对复杂变量建立类型别名的方式：[参考文章2](https://blog.csdn.net/suxiang198/article/details/46836965)
>
>      > **例1：int \*(*a[5])(int, char*);**//这是一个函数指针数组，函数的输入参数为int和char*类型，返回值为int型的指针
>      >
>      > `typedef int *(*pFun)(int, char*);//pFun是建的一个类型别名`
>      >
>      > `pFun a[5];//使用定义的新类型来声明对象`，等价于 `int* (*a[5])(int, char*);`
>      >
>      > **例2：void (\*b[10]) (void (*)());**
>      >
>      > `typedef void (*pFunParam)();//首先为上面表达式(void (*)())部分声明一个新类型`
>      >
>      > `typedef void (*pFun)(pFunParam);//整体声明一个新类型`
>      >
>      > `pFun b[10];//使用定义的新类型来声明对象`，等价于 `void (*b[10]) (void (*)());`
>      >
>      > **例3：double(\*(*pa)[9])();**
>      >
>      > `typedef double(*pFun)();//首先为整体声明一个新类型`
>      >
>      > `typedef pFun (*pFunParam)[9];//再为上面((*pa)[9])部分声明一个新类型`
>      >
>      > `pFunParam pa;//使用定义的新类型来声明对象`，等价于 `double(*(*pa)[9])();`

### 函数指针

> 指向函数的指针变量。函数指针可以像一般函数一样，用于调用函数，传递参数。函数指针的声明：
>
> ​	> `typedef int (*fun_ptr)(int, int);//声明一个指向同样参数、返回值的函数指针类型`

### 回调函数

> 函数指针作为某个函数的参数  [回调函数-参考文档](http://www.runoob.com/cprogramming/c-fun-pointer-callback.html)
>
> > 函数指针变量可以作为某个函数的参数来使用，回调函数就是一个通过函数指针调用的函数。
> >
> > 简单讲：回调函数是由别人的函数执行时调用你实现的函数。